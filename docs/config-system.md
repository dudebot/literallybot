# Configuration System Documentation

LiterallyBot uses a JSON-based configuration system that supports per-guild, per-user, and global settings with automatic persistence and write buffering.

## Overview

### Storage Types
- **Global Config**: `configs/global.json` - Bot-wide settings (superadmin, global features)
- **Guild Config**: `configs/{guild_id}.json` - Server-specific settings (admins, features, server preferences)  
- **User Config**: `configs/user_{user_id}.json` - Individual user preferences and data

### Key Features
- **5-second write buffering**: Batches rapid config changes to reduce filesystem I/O
- **Atomic writes**: Uses temporary files with atomic rename to prevent corruption
- **Cross-platform**: Handles Windows and Unix filesystem differences
- **Thread-safe**: Safe for concurrent access from multiple cogs

## Basic Usage

### Accessing the Config System
The config system is available as `self.bot.config` in all cogs:

```python
class MyCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
    
    @commands.command()
    async def my_command(self, ctx):
        # Access config here
        value = self.bot.config.get(ctx, "my_setting", "default")
```

### Guild-Specific Settings (Default)
```python
# Get guild setting with default
prefix = self.bot.config.get(ctx, "prefix", "!")

# Set guild setting  
self.bot.config.set(ctx, "prefix", "?")

# Example: Server-specific feature toggles
music_enabled = self.bot.config.get(ctx, "music_enabled", True)
self.bot.config.set(ctx, "music_enabled", False)
```

### User-Specific Settings
```python
# Get user preference
timezone = self.bot.config.get_user(ctx, "timezone", "UTC")

# Set user preference
self.bot.config.set_user(ctx, "theme", "dark")

# Alternative syntax with scope parameter
theme = self.bot.config.get(ctx, "theme", "light", scope="user")
self.bot.config.set(ctx, "theme", "dark", scope="user")
```

### Global Settings
```python
# Get global setting
maintenance_mode = self.bot.config.get_global("maintenance", False)

# Set global setting
self.bot.config.set_global("maintenance", True)

# Alternative syntax
superadmin = self.bot.config.get(None, "superadmin", scope="global")
```

## Working with Lists and Arrays

Managing arrays in config requires manual operations:

```python
# Add item to list
admins = self.bot.config.get(ctx, "admins", [])
if user_id not in admins:  # Check for duplicates if needed
    admins.append(user_id)
    self.bot.config.set(ctx, "admins", admins)

# Remove item from list
blocked_users = self.bot.config.get(ctx, "blocked_users", [])
if user_id in blocked_users:
    blocked_users.remove(user_id)
    self.bot.config.set(ctx, "blocked_users", blocked_users)
```

### Cleanup Expired Data
For data with expiration timestamps:

```python
import time

# Remove expired items manually
items = self.bot.config.get(ctx, "temp_data", [])
current_time = time.time()
active_items = [item for item in items if item.get("expires", 0) > current_time]
if len(active_items) != len(items):
    self.bot.config.set(ctx, "temp_data", active_items)
```

## Real-World Examples

### Permission System (Admin Cog)
```python
# Check if user is admin
admins = self.bot.config.get(ctx, "admins", [])
if ctx.author.id not in admins:
    await ctx.send("You don't have permission.")
    return

# Add new admin
admins = self.bot.config.get(ctx, "admins", [])
if new_user.id not in admins:
    admins.append(new_user.id)
    self.bot.config.set(ctx, "admins", admins)
```

### User Preferences (Hypothetical Settings Cog)
```python
@commands.command()
async def set_timezone(self, ctx, timezone: str):
    """Set your personal timezone"""
    # Validate timezone here...
    self.bot.config.set_user(ctx, "timezone", timezone)
    await ctx.send(f"Timezone set to {timezone}")

@commands.command() 
async def my_settings(self, ctx):
    """View your personal settings"""
    timezone = self.bot.config.get_user(ctx, "timezone", "UTC")
    theme = self.bot.config.get_user(ctx, "theme", "default")
    await ctx.send(f"Timezone: {timezone}, Theme: {theme}")
```

### Feature Toggles (Per-Guild)
```python
@commands.command()
async def toggle_music(self, ctx):
    """Toggle music functionality for this server"""
    current = self.bot.config.get(ctx, "music_enabled", True)
    self.bot.config.set(ctx, "music_enabled", not current)
    status = "enabled" if not current else "disabled"
    await ctx.send(f"Music {status} for this server")
```

### Memory System (GPT Cog Pattern)
```python
# Store user interaction with expiration
memory_item = {
    "text": user_message,
    "expires": time.time() + (30 * 24 * 60 * 60),  # 30 days
    "type": "conversation",
    "user_id": ctx.author.id
}

memories = self.bot.config.get(ctx, "memories", [])
memories.append(memory_item)
self.bot.config.set(ctx, "memories", memories)

# Later, clean up expired memories  
memories = self.bot.config.get(ctx, "memories", [])
current_time = time.time()
active_memories = [m for m in memories if m.get("expires", 0) > current_time]
if len(active_memories) != len(memories):
    self.bot.config.set(ctx, "memories", active_memories)
```

## Advanced Usage

### Manual Flush
Force immediate save (useful before bot shutdown):
```python
# Force all pending writes to disk
self.bot.config.flush()
```

### Context-Free Usage
When you don't have a Discord context:
```python
# Using user ID directly
self.bot.config.set_user(user_id, "last_seen", time.time())

# Using guild ID directly  
self.bot.config.set(guild_id, "maintenance", True)
```

### Complex Data Structures
```python
# Store nested objects
user_stats = {
    "commands_used": 42,
    "last_active": time.time(),
    "preferences": {
        "notifications": True,
        "compact_mode": False
    }
}
self.bot.config.set_user(ctx, "stats", user_stats)

# Access nested data
stats = self.bot.config.get_user(ctx, "stats", {})
commands_used = stats.get("commands_used", 0)
```

## Migration from Old Config

If you have existing code using the old config system:

```python
# Old approach still works (guild scope by default)
value = self.bot.config.get(ctx, "key", default)
self.bot.config.set(ctx, "key", value)

# New features available
user_value = self.bot.config.get_user(ctx, "user_key", default)
global_value = self.bot.config.get_global("global_key", default)
```

## Performance Notes

- **Write Buffering**: Config changes are batched and written every 5 seconds
- **Memory Usage**: All configs are kept in memory for fast access
- **File I/O**: Atomic writes prevent corruption but require temporary files
- **Concurrency**: Thread-safe for multiple cogs accessing config simultaneously

## Best Practices

1. **Use appropriate scope**: Guild for server settings, user for preferences, global for bot-wide settings
2. **Provide defaults**: Always specify sensible default values
3. **Validate input**: Check user input before storing in config
5. **Clean shutdown**: Call `self.bot.config.flush()` before bot termination if needed